{
   "README" : "DPL (Descriptor/PrimaLisp) Components",
   "README-00-eval" : "eval\n\n  if data is the noun, evaluation is the verb.\n\n  a string is evaluated.\n  it is either a literal,\n                 quoted string,\n                 function/macro call,\n                 comment (all expressions), or\n                 malformed.\n\n  a value is returned or an exception is thrown.\n\n  that's basically it.  over and over again.  recursively.\n  until it's done.  if it finishes.\n\n  'evaluate an expression', 'run a program', and 'interpret/execute some instructions/code'\n  really all mean about the same thing, runtime environment details notwithstanding:\n\n                              *do* the thing described herein",
   "README-10-PrimaLisp" : "⚡ PrimaLisp, a low-syntax expression language\n\n‣ S expression based,\n      nested parens determine functional/hierarchical composition,\n      whitespace separates things.\n\n    reserved chars:\n        whitespace                   separates expressions\n\n        single & double quote  ' \"   indicates quoted strings,\n                                     double quotes do variable interpolation\n\n        left & reight brackets [ ]   indicates a list.\n\n        left & right braces    { }   indicates a hash.\n\n        left & right parens    ( )   indicates a function call.\n                                     first slot is function, rest are args.\n                                     () is the undefined value.\n\n        dollar                  $    indicates variable reference shorthand:\n                                     these two are equivalent: $Expr (var-get Expr)\n\n        at                      @    indicates list/hash interpolation in a function call.\n                                     items from the following list (or name/value pairs\n                                     from the following hash)\n                                     appear as parameters to the called function.\n                                     currently limited to parameter slots.\n\n        comma                   ,    force eval of next expression.\n\n    a sequence of non-reserved chars evaluates to itself\n    (so doesn't need to be quoted), and is a valid variable name.\n\n‣ first class functions/function literals,\n  variadic prefix operators,\n  dynamically scoped multi-namespaced variables,\n\n   context dependant magic chars:\n      ampersand   &    (fn (... &var) ...)\n                       preceeds one var name in param list of lambda expression.\n                       var''s value is a list of the remaining parameters passed to the function.\n\n      dash dash   --   (fn (... -- ...) ...)\n                       a convention used to separate formal parameters passed to the\n                       function from the dynamically scoped variables being declared.\n\n      colon       :    (Prefix:FunctionName ...)\n                       a naming convention used to indicate functions\n                       defined in a builtin extension (dpli) file.\n\n‣ exceptions, classes, instances and method calls,\n  (catch (do stuff) (report 'Exception: %s' (desc-to-string $_err)))\n  (throw {foo bar})\n\n  (= inst (new-inst Class ...))\n  ($inst do-something)\n\n\n‣ list interpolation, lazy evaluation, \n\n‣ extensible builtin functions, lisp macros, JSON data type.\n\n\n  kernel 0 functions:  if while catch expr-to-list lambda  (function-call args ...)\n  kernel 1 functions:  eval return throw parse bi-import",
   "README-20-Descriptor" : "Descriptor\n  what you get when you deserialize a\n  JSON object, array, string, 'true', 'false' or 'null'.\n\n     serialized: any valid JSON encoding of a data object.\n  de-serialized: corresponding in-memory data object.\n\n  DPL maintains a flat list of files containing JSON text,\n  with updates automatically versioned.\n\n  These descriptors can contain whatever,\n  including functions that are called when corresponding endpoints are hit.",
   "README-25-DPL" : "DPL Descriptor/PrimaLisp\n  Uses nested JSON objects as a hierarchical container for PrimaLisp expressions,\n  typically function literals.  \n\n  Some reserved names:\n\n  /on-load    called when (desc-read) loads the descriptor\n    Typically calls (def-hash-fn) to define other functions from\n    code in the descriptor.\n\n  /main       called when URI http:/.../api/dplx/DESC/... is hit.\n\n  /rcs-id     version control info.\n\n  /api-entry-points  webservice request filter/handlers\n    /api-handlers\n    /request-schema",
   "README-30-Source-Code" : "Source Code\n  PrimaLisp expressions can be stored in a text file\n  and evaluated/executed as a script or with the dpl command.\n\n  Expressions can also be evaluated with the eval service at  http:/api/eval\n\n  DPL source code consists of PrimaLisp expressions (e.g. function definitions)\n  stored as strings within a JSON object. This JSON object typically contains\n  nested hashes, the names of which form the 'path' to the final hash.",
   "README-40-Editor" : "Editor; browser UI,\n  http:/api/dple/...\n    A nested hash/descriptor can be addressed by\n    a path made from its corresponding keys.\n\n    It can be edited with a browser by going to\n      .../api/dple/DescriptorName/Nested/Hash/Path/Name",
   "README-50-webservice-endpoints" : "webservice endpoints\n  http:/api/dplx/...\n    A Descriptor can be run from a web client by going to\n        .../api/dplx/DescriptorName/URL/PATH/INFO\n\n    If the named descriptor has a top level field called 'main',\n    that field is evaluated.\n\n    The value returned should be a  function literal/lambda expression,\n    which will be called to handle the request.\n\n  http:/api/eval\n    a GET returns a form which takes PrimaLisp expressions and submits them for evaluation.\n    a history of past evaluation is maintained, like a shell history.\n\n    PrimaLisp expressions in the body POST''d to this endpoint will be evaluated\n    and the result returned as the response.",
   "README-55-eval-endpoint" : "See README/philosophy/015-eval-endpoint",
   "README-60-runtime-environments" : "runtime environments\n  command line\n     dpl\n       - repl from stdin\n       - eval from cmdline/stdin/file\n       - update local installation\n       - full access to underlying system\n\n     dplx ...\n       - invoke webservice call from cmdline or as Apache cgi-bin\n       - limited access to underlying system\n\n  dplx -- Apache cgi-bin\n\n  dpld -- standalone webserver",
   "README-70-Eval-README" : "Eval README\n\n  http://.../api/eval/README",
   "README-70-Man-Pages" : "Man Pages\n\n  http:/api/dplx/man",
   "README-80-HTML-Constructors" : "HTML constructors\n\n  (desc-read _ HTML-macros)",
   "README-90-Tests" : "Tests\n\n  dplx Tests\n\n  http://.../api/dplx/Tests",
   "README-A0-Examples" : "Examples\n\n  http://.../api/eval/Examples",
   "_dateCreated" : "Fri Nov 11 23:03:07 2011",
   "_useCount" : 176,
   "dplx-docs" : {
      "README" : "DPL webservice request dispatcher docs\n\n (webservice calls to http://.../api/dplx/~target-desc~)\n\nIn this implementation, the DPL dispatcher consists of two parts;\nA webserver-facing part (in this case a cgi-bin, but could also be mod_perl say,\nor a standalone webserver like dpld), and a descriptor-facing part which\nloads and invokes the target descriptor.\n(btw, the webserver has '/api' configured as an alias for '/cgi-bin')\n\nThe first part is a cgi-bin script 'dplx' which is invoked by the Apache webserver\nto handle the request.  This script collects information about the request from\nthe environment, constructs a PrimaLisp interpreter and uses the interpreter to\neval the request 'bootstrap' code.\n\nThe second part is the DPL descriptor 'dplx' which gets invoked via the bootstrap code.\nThis descriptor finishes the request dispatch by loading the target descriptor\nand calling its (main), or filtering the request using api-entry-points and evaling the\nassociated handler code.\n\n--\n\nOn entry to (main) in the target descriptoer these variables will have been set,\naccording to the particulars of the request:\n  user-agent            \n  path-info             \n  query-hash            \n  request-method        \n  request-content-type  \n  request-content  \n     \nThe target descriptor (the one to be invoked) is identified from path-info and loaded.\nThe descriptor's  request-from-client  schema (if present) defines a tree of\n\"$request-method/$path-info\" patterns the descriptor will accept.\nIf no schema is defined, the descriptor's (main) function is called.\n\nThe function  (find-handler)  returns the matching 'handler'\nbased on specific $request-method and $path-info values for this request.\nIf no matching handler is found, an exception is thrown.\n\nThe value returned by (find-handler) is a map (presumed to be)\ncontaining an '.on-match.' field.  If not, an exception is thrown.\nThis contents of this field will soon after be eval'd,\nand may produce the response or not.\n\nIf a complete response is produced by this handler code,\nit must return undefined to signal completion.\nBy convention a non-zero value is returned to signal\nthat no response at all has been produced.\nPartial responses should probably be avoided.\n\nIn the case that no response was produced (non-zero return),\nor that there was no request-from-client schema (no api handlers, simpler case),\nthe target descriptor's (main) function will be called.\n\nPath components must match corresponding paths in the schema exactly.\nOtherwise, path components of the form  ~{var-name}~  act as wildcards.\nIn this case the path component is deemed to match and\nits value is saved in the variable  req-{var-name}.\n\nOtherwise an exception is thrown.\n\nThrown exceptions result in some form of HTTP error response."
   },
   "philosophy" : {
      "010-web-oriented" : {
         "README" : "* Web oriented, not System oriented\n\n  Machines and OSs are important, providing processes to run in and\n  files for persistance.  These resources are so important that developers\n  go to alot of effort to prevent 'unauthorized' remote access.\n\n  But such access is only possible because an application's programming\n  language typically provides the means access to these resources at all.\n  In this context, running arbitrary code from the web is exactly what you\n  are trying to avoid doing.\n\n  So wtf would anyone want to run arbitrary code from the web anyway?\n     See eval endpoint.\n\n  ...\n\n  DPL doesn't provide any way to access 'local' files and processes directly;\n  all the interesting stuff is 'out there' anyway.\n\n  This makes it 'safe' to run arbitrary web-editted code.\n  Imagine a wiki you write code in!\n\n  Code/test/run from anywhere you can run a browser,\n    not tied to a VNC/desktop development environment.\n\n  A language with builtin mechanisms for producing and consuming webservices.  \n    Stub-out a callable HTTP API in seconds.\n\n  Descriptor <-> deserialized JSON Object.\n  Descriptor <-> DPL's data type.\n  Descriptor <-> unit of persistant storage\n                 (e.g. serialized descriptor (JSON object) stored in a file)\n  Descriptor <-> container for PrimaLisp code [1]\n  Descriptor <-> webservice endpoint handler and class\n\n  [1] edited with a wiki-inspired browser based code editor.\n\n\n  Do I even have to mention it's UTF-8/Unicode friendly?\n  C'mon, it's 2012!  ISO-8859-1 is so 20th century..."
      },
      "015-eval-endpoint" : {
         "README" : "* Eval API endpoint\n\n  Here's one motivating problem:  Non-composable web APIs.\n\n  Web APIs kinda suck in that they have fixed functionality.\n  Any composite functionality must be implemented programmatically at the client,\n  and it costs extra round trips to use. Or you have to wait for that composite\n  functionality to please be implemented within the API as a new point of\n  fixed functionality.\n\n  Instead, the basic functionality should be exposed as say simple functions,\n  and a programming language used to compose the basic functionality\n  into whatever is needed at the time.\n\n  The web API request (now to a single endpoint) looks like a little program.\n  The server handles the request by running the program whose output/return value\n  is the response.\n\n  (think of calling a DB stored proc, or rendering a PostScript® file)\n\n  But, we need a new language so such arbitrary web-supplied code is 'safe' to run.\n  (and the simpler the basis of such a language, the better.)\n\n  Or we could lobotomize an existing language and hope that works out... \n\n\n  Solution:\n\n  One HTTP endpoint:  http://DPL-Host/api/eval\n\n  POST PrimaLisp expressions to the endpoint,  Content-Type: text/plain\n    the expressions can a single function call or a complete program.\n\n  The expressions are evaluated and the result is returned as the response.",
         "more" : "the eval API endpoint\n\n  Often a web API is exposed as a set of URI endpoints on which a variety\n  of HTTP calls can be made (in particular, HTTP GET), with defined responses.\n  The problem arises when various granularities of functionality are needed by\n  API clients.\n\n      Basic functionality of accessing an item by id is nice,\n      but now we have a list of ids of items we want to access,\n      and hitting the API once per kinda sucks.\n\n      So we add a 'batch' version of selected calls.\n\n      Now we want some other operation that produces ids to be\n      the source of ids of items to access.\n\n      So we add a 'query' version of some other selected calls,\n\n      Etc.  Nothing that couldn’t be done hitting the basic API,\n      but doing so is relatively slow and limits the scope for Wow!\n      And it gets to be a mess.\n\n  And the dev at the other end of the API (a programmer familiar with\n  using languages and libraries to, you know, write code) has to hope\n  we have exposed the right endpoints to do some magic with the API\n  (you know, surprise you with what you didn’t know could be done with\n  your API).\n\n\n  What if, instead of an API like a multidimensional button array on some\n  crazy vending machine, we had an API with one button you pressed and\n  told the vending machine what you wanted out of it.  The vending machine\n  is smart enough to evaluate what you said and do whatever you told it to do\n  (or to give up if it just can’t), but not smart enough to be able to do\n  anything dangerous. Annoying, maybe, but not dangerous.\n\n\n  What it looks like is that our eval API is now exposed as a library of\n  functions/methods to be called from an actual programming language.\n  Our one eval API endpoint takes expressions in this language,\n  evaluates them and returns the result.\n\n  To use the eval API, our dev now writes expressions in this programming language.\n  These expression can define functions which are later called, and in general\n  can be thought of as scripts/programs that generate the response.\n\n  The request is a program that generates the response.\n\n  The simplest use case in this eval API would be a single function call,\n  maybe taking some arguments.\n\n  But OMG, WTF do we need yet another language for?\n\n  Because the request is a program that generates the response.\n\n  The eval API explicitly invites the execution of 'arbitrary code',\n  but in the language of *our* choice.\n\n  Other languages are too smart for this role, which makes them dangerous.\n  They’d need to be lobotomized to be able to 'safely' run such arbitrary\n  code on someonse server.  Do you really want that for your favourite language?\n  \n  (actually, PrimaLisp is too smart too, but is it’s designed\n  to be suitably lobotomized, as it is when handling the eval API, other\n  webservice endpoints, or loading any web-edited code.)\n\n  Our dev gets to apply programming skills to compose our API primitives\n  into something new and wonderful (up to and beyond sending us a whole program\n  right there in the API request), and we get to focus on building new\n  functionality (exposed through working useful composible API primitives).\n\n  Now, when a use case appears that would seem to require a new endpoint to\n  combine existing functionality in a particular way, our dev can just write\n  the appropriate code into a request and get shit done, instead of waiting for\n  an API change to roll out.\n\n\n  So, we can write a client in DPL, that talks to a service written in DPL.\n  The client sends requests to the service (requests that are also\n  written in DPL) and gets back JSON responses that are deserialized\n  to DPL’s data type.  Essentially, the client sends parts of itself\n  within a request that is run within the service, and gets results back\n  that are used like any other DPL data."
      },
      "020-safety" : {
         "README" : "* Safty, Extensibility, Performance\n\n  The only functionality ultimately available to PrimaLisp code is that exposed by\n  its set of builtin functions.  Builtins can be dropped, builtins can be imported;\n  both restricting and extending the language.  The default has no builtins\n  that provide direct access to the filesystem or processes.  Performance\n  hot spots can be re-implemented as builtin function in the implementation\n  language.\n\n  If you write and use builtin extensions that have gaping security holes,\n  you should expect the worst."
      },
      "030-rapid-iteration" : {
         "README" : "* Rapid edit-test iteration cycle\n\n  <10s cycle time, if you can keep up!\n  you don't   w  a  i  t   for the computer to go through some gyrations\n  before seeing the effect of a change.\n\n  you stay deeper in the zone, for longer.\n  you get qualitatively *better* shit done, quicker.\n\n  NB: shit you *could not* get done by working\n    longer and harder, not in the zone, i.e. competitive advantage."
      },
      "040-virtualized" : {
         "README" : "* Virtualized, Distributed  language\n\n  DPL targets other languages rather than a hardware or VM architecture.\n\n  But rather than generating code in the target language, the PrimaLisp\n  builtin functions and the runtime environment (RTE) are implemented in\n  the target language.  The RTE evaluates PrimaLisp code, which generally\n  involve calling builtin functions at various points.  The higher level\n  the target language, the easier it is to implement a PrimaLisp RTE\n  in that language.\n\n  In one sense, evaluation of a PrimaLisp program can be viewed as PrimaLisp\n  code running for a while, interspersed with calls to builtin functions,\n  wherein target language code runs for a while. \n\n  With a RTE implemented in language X, builtin functions can be written\n  in language X which extend the RTE and provide an PrimaLisp API\n  to any library written in/for X.  This mechanism allows PrimaLisp code on\n  this RTE to call into libraries for language X.\n\n  Also, code running on one RTE can send code to various other RTEs for\n  'remote' evaluation.\n\n  This gives PrimaLisp code (running on a varied cluster of RTE implementations\n  with the right extensions and native libraries installed) access to more\n  library functionality than any other mainstream language."
      },
      "050-split-level" : {
         "README" : "* Split-level language\n\n  'PrimaLisp' is the lispy S expression language that does stuff.\n  The runtime environment only ever evaluates PrimaLisp expressions.\n\n  'DPL' is the structural language which uses a JSON object as a persistant\n  (hierarchical) container for a number of PrimaLisp expressions,\n  typically lambda expressions/function literals or other data objects.\n  This DPL 'program' can implement a webservice endpoint, class or library.\n\n  Sometimes the two names are used interchangably..."
      },
      "060-packaging-deployment" : {
         "README" : "* Packaging and Deployment handled within the RTE\n\n  packaging a distribution file and deploying updates\n  pulled from another DPL server are builtins\n\n  A call to (get-DPL-dist) returns a zip or tar.gz distribution file\n  containing the called runtime's deployed files.\n\n  A call to (update-DPL-dist -host-port-) contacts the DPL runtime\n  at -host-port- to obtain a distribution file, and deploys it on\n  the local runtime.  From the command line this can be done by running:\n\n    dpl -update Host:Port"
      },
      "070-Misc" : {
         "README" : "Supports a bi-modal coding regime \n\n  Q&D prototype work to proof an idea and demo it in under an hour.\n  The means to robustify it for real production use as needed.\n    refactoring support via dynamic scoping"
      },
      "071-Misc" : {
         "README" : "Language Oriented Design\n\n  s expressions, lisp-oriented, naming conventions.\n  consistant syntax between various levels of language."
      },
      "072-Misc" : {
         "README" : "RTE vs Language\n\n  very dynamic interpreter for one end, JIT compiled for other end."
      },
      "README" : "DPL-Philosophy\n\nSee the links above for the subsections.",
      "_01-web-oriented" : ""
   },
   "rcs-id" : "$Id: README,v 1.186 2013/03/06 05:58:40 apache Exp apache $"
}
