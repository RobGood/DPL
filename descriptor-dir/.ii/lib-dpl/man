{
   "README" : "Reference manual pages",
   "_dateCreated" : "Thu Jul 14 12:17:50 2011",
   "_useCount" : 611,
   "api" : {
      "get-man-page-hash" : "// Lookup the page hash for the query term in the man.docs index.\n\n(fn (query -- docs-dirty? idx page-hash edit-link)\n  (= queryE (utf8-encode $query))\n  (= queryD (utf8-decode $query))\n  (report ' >> (get-man-page-hash %s)' $queryD)\n\n  (desc-read docs $man-docs-desc-name (hash reload 1))\n  (= docs-dirty? 0)\n\n  (= page-hash (get-page-hash $docs $query))\n\n  (if $docs-dirty? (do\n    (report \"Writing $man-docs-desc-name\")\n    (desc-write $docs $man-docs-desc-name)))\n\n  (hash-set $page-hash / 015-Usage (expr\n    (html-ul (map-list (fn (_) (html-li $_)) (help $queryE)))))\n\n  (= synop (hash-get $page-hash / 01-Synopsis))\n  (if (ne '' $synop)\n    (hash-set $page-hash / 01-Synopsis (expr\n      (html-pre $synop))))\n\n  (= edit-link (sprintf /api/dple/%sman.docs/pages/%s $section. $i-query))\n\n  (hash-set $page-hash / edit-link $edit-link)\n  (hash-set $page-hash / synop-code $synop)\n\n  $page-hash\n)",
      "get-page-hash" : "(def-fn find-largest+1 ( -- max)\n  (report ' >> (%s)' $.)\n\n  (= max -1)\n  (map-list (fn (k -- v)\n      (= v (hash-get $idx / $k))\n      (report 'k: %s, v: %s' $k $v)\n      (if (< $max $v) (= max $v)))\n    (hash-keys $idx /))\n  (++_ max))\n\n(fn (docs query -- idx queryE)\n  (= queryE (utf8-encode $query))\n  (= queryD (utf8-decode $query))\n  // (report ' >> (get-page-hash %s %s)' $docs $queryD)\n\n  (= idx (get-page-index $docs))\n  // (report 'idx: %s' (desc-to-string $idx))\n\n  // Get the id corresponding to the query term.\n  // Give it the next id if we've not seen it.\n  //   (the number of keys happens to be just right!)\n  (= i-query (hash-get $idx / $queryD)) //E\n  (if (undef? $i-query) (do\n    // Could also fail instead...\n    (= i-query (find-largest+1))\n    (report 'No id found for query %s, new id: %s' $queryD $i-query)\n    (hash-set $idx / $query $i-queryD) //E\n    (= docs-dirty? 1)\n  ))\n\n  // (report 'i-query: %s' $i-query)\n\n  // Look up the page info hash.\n  // Copy one from the template if we've not seen it.\n  (= page-hash (hash-get $docs /pages $i-query))\n  (if (undef? $page-hash) (do\n    (report 'Undefined page hash for %s' $queryD)\n\n    (= page-hash (hash-get $docs /pages 0000-template))\n    (if (undef? $page-hash) (do\n      (= page-hash (hash-get $docs /pages 000))\n      (hash-set $docs /pages 0000-template (hash-clear $docs /pages 000))\n    ))\n\n    // deep copy.\n    (= page-hash (desc-from-string (desc-to-string $page-hash)))\n\n    (hash-set $page-hash / 0-command $query)\n    (hash-set $page-hash / 00-Name  \"$query - \")\n\n    (hash-set $docs /index $query   $i-query)\n    (hash-set $docs /pages $i-query $page-hash)\n\n    (= docs-dirty? 1)\n  ))\n\n  $page-hash\n)",
      "get-page-index" : "// Get index mapping query term to page id (mostly to make editing easier...)\n// Make an index if there's none.\n(fn (docs -- idx cmd)\n  (= idx (hash-get $docs / index))\n  (if (defined? $idx) (return $idx))\n\n  (report 'No index found, making one...')\n  (= idx (hash))\n  (foreach i-query (sort-alpha (hash-keys $docs /pages))\n     (= cmd (utf8-decode (hash-get $docs \"/pages/$i-query\" 0-command)))\n     (report 'cmd: %s' $cmd)\n     (hash-set $idx / $cmd $i-query))\n\n  (hash-set $docs / index $idx)\n  (= docs-dirty? 1)\n\n  (report 'idx: %s' (desc-to-string $idx))\n\n  $idx\n)",
      "html" : {
         "listing-to-html" : "(fn ()\n  (= surpress (hash-eval $self / surpress))\n\n  (= listing (sort-alpha (grep (fn (_) \n        (&& (ne '' $_) (ne 0 (substr $_ 0 1)) (undef? (hash-get $surpress / $_)) ))\n    (hash-keys (get-page-index $docs) /))))\n\n  (if $docs-dirty? (desc-write $docs $man-docs-desc-name))\n\n  // (report 'listing: %s' (desc-to-string $listing))\n\n  (= title 'DPL man page listing')\n  (= n (list-len $listing))\n  (report 'listing len: %d' $n)\n\n  (= n-cols 8)\n  (= n-rows (+ (int (/ $n $n-cols)) (if (% $n $n-cols) 1 0)))\n\n  (= ii 0)\n\n  (= n-filled-descriptions 0)\n  (= n-empty-descriptions 0)\n\n  (= man-listing-label\n    (sprintf 'DPL man pages%s'\n      (if (eq '' $section) '' \"; descriptor <i>$section</i>\")))\n\n(catch\n  (html-html\n    (html-head\n      (html-title $title))\n\n    (html-body $html-body-args\n      (html-h 3 $man-listing-label)\n\n      (if $n (concat\n        '<table width=\"100%\">'\n        (foreach row (.. 0 (- $n-rows 1)) (concat\n           <tr>\n           (foreach col (.. 0 (- $n-cols 1)) (concat\n              <td>\n                (if (defined? (= name (ith $listing (+ $row (* $n-rows $col))))) (do\n                  (report 'name: %s' $name)\n                  (man-link $name))\n                  '')\n              </td>\n           ))\n           </tr>\n        ))\n        </table>\n\n        <br/>\n        (html-h 3 'Other descriptor man pages')\n        (html-ul\n          (foreach md (desc-list *.man.docs) \n             (= md (substr $md 0 -9)) \n             (html-li (html-link \"/api/dplx/man/desc/$md\" $md))   \n          )\n          <br/>\n          (html-link /api/dplx/man 'DPL man pages')\n        )\n\n        <br/><br/>\n\n        (html-p (sprintf 'empty: %s, not: %s, %.1f%% done.'\n            $n-empty-descriptions\n            $n-filled-descriptions\n            (* 100 (/ $n-filled-descriptions $n))))\n        (html-p \"rows: $n-rows, cols: $n-cols\")\n      ) Empty!)\n    )\n  )\n  \"<html><body>_err: $_err</body></html>\")\n)",
         "page-hash-to-html" : "(fn (query -- page title heading x)\n  (= page (get-man-page-hash $query))\n\n  (= edit-link  (hash-clear $page / edit-link))\n  (= synop-code (hash-clear $page / synop-code))\n\n  (= man-listing-link\n    (sprintf /api/dplx/man%s\n      (if (eq '' $section) '' \"/desc/$section\")))\n  (= man-listing-label\n    (sprintf 'DPL man pages%s'\n      (if (eq '' $section) '' \"; descriptor <i>$section</i>\")))\n\n  (= title (sprintf '%s -- DPL man' (do $query)))\n  (= headings (map-list (fn (_ -- x)\n      // Strip off numeric prefix\n      (= x (split - $_)) (shift $x) (= x (join - $x))\n\n      (hash-set $page / $x (hash-get $page / $_))\n      $x)\n    (sort-alpha (hash-keys $page /))))\n\n  (shift $headings)\n\n  (html-html\n    (html-head\n      (html-title $title))\n\n    (html-body $html-body-args\n      (html-p\n        (bracket-link (html-link $man-listing-link $man-listing-label))\n        (bracket-link (html-link $edit-link 'edit')))\n\n      '<table border=\"0\" cellpadding=\"0\" cellspacing=\"5\">'\n      (foreach head $headings\n        (concat\n          '<tr valign=\"top\">'\n            '<td colspan=\"2\">' <b> (do (if (eq Synopsis $head) \n                    (sprintf '<a href=\"%s\" title=\"%s\">%s</a>'\n                       (xmlencode (sprintf '/api/eval?load=%s' (urlencode $synop-code)))\n                       'Click to edit/run this code'\n                       $head)\n                    $head)) </b>\n            </td></tr>\n\n          '<tr valign=\"top\">'\n            '<td width=\"10%\">'\n            <td>  (do (= x (hash-get $page / $head))\n                      (if (eq '(' (substr $x 0 1))\n                        (eval $x) $x))\n            </td>\n          </tr>\n        )\n      )\n      </table>\n\n    )\n  )\n)"
      }
   },
   "api-1" : {
      "man-link" : "(fn (&query-list)\n  (join ', '\n    (map-list (fn (query -- tmp rurl) \n       (= tmp (split : $query))\n       (= query (pop $tmp))\n\n       (if (list-len $tmp) (var-push section (shift $tmp)))\n       (= rurl (man-rurl $query))\n       (if (list-len $tmp) (var-pop section))\n\n       // (if (eq compile $query) (var-dump (hash allns 1)))\n\n       (concat\n        (html-link\n          $rurl\n          (sprintf <tt>%s</tt> (if (macro? $query) \"<i>$query</i>\" $query)))\n        '&#160;'\n        (mark-if-empty $query)))\n      $query-list))\n)",
      "man-rurl" : "(fn (name) (sprintf /api/dplx/man/%s%s\n  (if (eq '' $section) '' \"desc/$section/\")\n  //(urlencode (utf8-encode $name))\n  //(utf8-encode $name)\n  (if\n    (eq .. $name) %2E%2E\n    (urlencode (utf8-encode $name)))\n))",
      "mark-if-empty" : "(fn (name)\n  (= h (get-page-hash $docs $name))\n\n  (if (len (hash-get $h / 02-Description))\n    (do\n      (++_ n-filled-descriptions)      \n      '&#160;')\n    (do\n      (++_ n-empty-descriptions)\n      '<font color=\"#800000\">*</font>')))",
      "refresh-pages" : "(fn ( -- names)\n  (report ' >> (%s)' $.)\n  (hash-clear $docs / index)\n\n  (if (ne '' $section)\n    (throw \"Not expecting to refresh a section here! (section: $section)\"))\n\n  (= names (map-list utf8-decode (hash-keys (builtins) /)))\n  (= names (grep (fn (_) (&& (defined? $_) (ne '' $_))) $names))\n  (= names (sort-alpha $names))\n\n  (report 'names: %s' (desc-to-string $names (hash ascii 1)))\n\n  (map-list get-man-page-hash $names))"
   },
   "api-entry-points" : "{\n  GET/             1\n  GET/~query~      1\n  GET/desc/~head*   1\n}",
   "api-handlers" : {
      "1" : "1"
   },
   "main" : "(fn ( -- path-list)\n  (if (defined? $req-query)\n    (do\n      (report 'Assuming default section, query %s.' $req-query)\n      (= section (= section. ''))\n    )\n    (do\n      (= uri-path-list $req-path-list)\n      (unshift $uri-path-list $req-head)\n\n      (report 'uri-path-list: %s' (desc-to-string $uri-path-list))\n\n      (if (> (list-len $uri-path-list) 1)\n        (= req-query (pop $uri-path-list)))\n\n      (= section  (join . $uri-path-list))\n      (= section. (concat $section .))\n      (if (eq . $section.) (= section. ''))\n\n      (report 'Assuming section %s, %s.' $section\n        (if (defined? $req-query) \"query: $req-query\" 'no query'))\n    )\n  )\n\n  (= man-docs-desc-name   (concat $section. man.docs))\n  (report 'Reading man docs from %s' $man-docs-desc-name)\n  (desc-read docs $man-docs-desc-name)\n\n  // TODO: Read in defining descriptor to define functions in a \n  // separate namespace, to be able to tell which ones are macros.\n\n  (if (hash-get $query-hash / refresh) (refresh-pages))\n\n  (reply-html (if (defined? $req-query)\n    (page-hash-to-html (utf8-decode (urldecode $req-query)))\n    (listing-to-html))))",
   "on-load" : "(fn ()\n  (desc-read _ HTML-macros)\n\n  (def-hash-fn $self /    reply-usage)\n  //(def-hash-fn $self /    reply-html)\n\n  (def-hash-fn $self /api-1 man-rurl)\n  (def-hash-fn $self /api-1 man-link)\n  (def-hash-fn $self /api-1 refresh-pages)\n  (def-hash-fn $self /api-1 mark-if-empty)\n\n  (def-hash-fn $self /api get-page-index)\n  (def-hash-fn $self /api get-man-page-hash)\n  (def-hash-fn $self /api get-page-hash)\n\n  (def-hash-fn $self /api/html listing-to-html)\n  (def-hash-fn $self /api/html page-hash-to-html)\n\n  (def-fn report-var (&vars)\n    (report %s (join ', ' \n      (map-list (fn (_) (sprintf '%s: %s' $_ $$_)) $vars))))\n\n  (= app-server (hash-get (http-headers) / Host))\n\n  (= html-body-args (hash\n      link    white\n      vlink  '#a0a0a0'\n      text    white\n      bgcolor black\n  ))\n)",
   "rcs-id" : "$Id: man,v 1.619 2013/03/05 17:46:55 apache Exp apache $",
   "reply-html" : "(fn (html)\n  (ct 'text/html; charset=UTF-8')(bl)\n  (emit $html)\n)",
   "request-from-client" : {
      "schema" : {
         "HTTP" : {
            "GET" : {
               ".on-match." : "(hash-eval $self /api-handlers 1)",
               "desc" : {
                  "~head*" : {
                     ".on-match." : "(hash-eval $self /api-handlers 1)"
                  }
               },
               "section" : {
                  "~head*" : {
                     ".on-match." : "(hash-eval $self /api-handlers 1)"
                  }
               },
               "~query~" : {
                  ".on-match." : "(hash-eval $self /api-handlers 1)"
               }
            }
         }
      }
   },
   "surpress" : "(hash\n  is-defined 1\n  is-undef   1\n  is-hash    1\n  is-list    1\n  is-string  1\n  is-sym     1\n  dump-vars  1\n  clear-var  1\n  push-var   1\n  pop-var    1\n  set-var    1\n  get-var    1\n\n  drop-builtins 1\n)"
}
