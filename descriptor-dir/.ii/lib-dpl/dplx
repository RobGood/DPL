{
   "README" : "This is the entry point for the DPL dispatcher.\n\nTODO: This needs api-entry-points, request-from-client is un-sourced!\nor not have dplx answer /version, provide a separate descriptor...",
   "_dateCreated" : "Wed Oct 13 01:47:16 2010",
   "_useCount" : 861,
   "api" : {
      "find-handler" : "// Look for a specific handler for the details of this request:\n//  HTTP method, path-info, query-hash, request content-type and body.\n// Walk along the given path components looking for a handler at the end.\n(fn ( -- handler)\n  // (report ' >> (%s %s)' $. $handler)\n\n  (= handler (desc-get $self /request-from-client schema))\n  (if (undef? $handler) (return))\n\n  (= handler (desc-get $handler /HTTP $request-method))\n  (if (undef? $handler) (throw 'http status 400 Bad Request.'))\n\n  (= part (shift $path-list))\n\n  (while (&& (defined? $handler) (defined? $part))\n    (= prev-handler $handler)\n    (= tmp (desc-get $handler / $part))\n\n    (= handler (if (defined? $tmp) $tmp (match-wildcards $handler)))\n    (= part (shift $path-list)))\n\n  (if (&& (undef? $handler) (defined? $prev-handler)) (= handler $prev-handler))\n\n  $handler\n)",
      "hash-set-unless-set" : "(fn (path name body) \n  (= path (eval $path))\n  (= name (eval $name))\n\n  (if (undef? (hash-get $self $path $name))\n    (hash-set $self $path $name (eval $body)))\n)",
      "match-wildcards" : "(def-fn wildcard? (str)\n  (&& (eq ~ (substr $str 0 1)) \n      (|| (eq ~ (substr $str -1))\n          (eq * (substr $str -1)))))\n\n\n(fn (handler -- wildcards wildcard base-name)\n  // (report ' >> (%s %s)' $. $handler)\n  // (report %s (desc-to-string (hash-keys $handler /))\n\n  (= wildcards (grep wildcard? (hash-keys $handler /)))\n\n  (if (== 0 (list-len $wildcards))  (throw 'http status 400 Bad Request..'))\n\n  (if (!= 1 (list-len $wildcards))\n    (throw (sprintf 'Expected a single wildcard here, got %s from %s'\n         (desc-to-string $wildcards) (desc-to-string $handler)  )))\n\n  (= wildcard  (first $wildcards))\n  (= base-name (substr $wildcard 1 -1))\n  (= \"req-$base-name\" $part)\n\n  (if (eq * (substr $wildcard -1)) (do\n    (unshift $path-list $part)\n    (= \"req-$base-name\" $path-list)\n    (= \"req-path-list\" $path-list)\n    (= path-list [])\n  ))\n\n  (desc-get $handler / $wildcard))",
      "matching-handler--no-response" : "(fn (h) // (report ' >> (matching-handler--no-response)')\n  (update-api-rules)\n\n  (= h (find-handler))\n  (if (undef? $h) (return 1))  // no api schema, accept everything.\n\n\n//  (defined? (if\n//    (defined? (= h (desc-get $h / .on-match-with-path. )))  ()\n//    (defined? (= h (desc-get $h / .on-match. )))            (eval-all $h)\n//        (throw 'http status 400 Bad Request...')))\n\n  (= h (desc-get $h / .on-match. ))\n  (if (undef? $h) (throw 'http status 400 Bad Request...'))\n\n  (defined? (eval-all $h))\n)",
      "schema-path" : "/request-from-client/schema/HTTP",
      "update-api-rules" : "(fn ( -- made-changes) // (report \" >> (update-api-rules)\")\n  (= api-list (hash-eval $self / api-entry-points))\n  (if (undef? $api-list) (return))\n\n  (= made-changes 0)\n\n  (if (list? $api-list) (update-api-rules-1 $api-list))\n  (if (hash? $api-list) (update-api-rules-2 $api-list))\n\n  // (report \"made-changes: $made-changes\")\n  (if $made-changes (desc-write $self $self/name))\n)",
      "update-api-rules-1" : "(fn (list -- path)\n  (map-list (fn (spec)\n       (= path \"$schema-path/$spec\")\n       (if (defined? (hash-set-unless-set $path .on-match. 1))\n         (= made-changes (+ 1 $made-changes))))\n    $list)\n)",
      "update-api-rules-2" : "(def-fn update-api-rules-2-1 (spec -- tmp)\n  (= fn-spec (hash-get $api-list / $spec))\n  (= tmp \"$base-path/$fn-spec\")\n  (= tmp (split '\\\\/' $tmp))\n  (= fn-name (pop $tmp))\n  (= fn-path (join '/' $tmp))\n\n  (if (defined? (hash-set-unless-set\n       \"$schema-path/$spec\" .on-match.\n          (sprintf '(hash-eval $self %s %s)' $fn-path $fn-name)))\n    (= made-changes (+ 100 $made-changes)))\n\n  (if (defined? (hash-set-unless-set $fn-path $fn-name 1))\n    (do \n      (= made-changes (+ 10000 $made-changes))\n      (report \"spec: $spec, fn-path: $fn-path, fn-name: $fn-name\")))\n\n  ()\n)\n\n\n(fn (list -- base-path path)\n  (= api-spec-list (hash-keys $api-list /))\n  (= base-path /api-handlers)\n\n  (= api-handler-list (map-list (fn (spec)\n         (hash-get $api-list / $spec)) $api-spec-list))\n\n  (map-list update-api-rules-2-1 $api-spec-list)\n\n  (update-api-rules-1 $api-spec-list)\n)"
   },
   "handler-pre" : "(def-fn set-up-cookies-and-session-id ()\n  (= cookies    (http-cookies))\n  (= session-id (hash-get $cookies / sid))\n\n  (if (defined? $session-id) (return))\n\n  (= session-id (md5-digest (sprintf %.6f:%s (time) $remote-addr)))\n  // (report 'Created session id: %s' $session-id)\n\n  (http-set-cookie sid $session-id {expires 'Sat, 21-Dec-2013 23:59:59 GMT'})\n)\n\n(fn ( -- hdrs) // (report \" >> (handler-pre)\")\n  (if (defined? $user-agent)\n    (set-up-cookies-and-session-id)))",
   "html" : {
      "html-app-template" : ""
   },
   "main" : "(fn (req-info --  response-header-complete)\n  // (report ' >> (%s %s)' $. (desc-to-string $req-info))\n\n  (if (defined? $req-info) (= $req-info))\n\n  // Split path-info on slashes, skip first empty item, confirm.\n  (= path-list (split / $path-info))\n\n  (if (&& (list-len $path-list) (ne '' (shift $path-list)))\n    (throw \"I didn't expect the Spanish Inquisition!\"))\n\n  // Take the name of the Descriptor to run from the first name in path-info.\n  (= target-desc (shift $path-list))\n\n  // Repackage path-info for downstream use.\n  // Maybe we should use path-list from here on instead?\n  (= path-info (sprintf '/%s' (join / $path-list)))\n\n  // No target given in path-info; see if we can handle it.\n  (if (undef? $target-desc) (do\n     (catch (if (matching-handler--no-response) (no-target 2))\n            (no-joy \"http status 404 $_err\" $_cs 1))\n     (return)))\n\n  (if (defined? $http-host) (do\n    (= target-desc-prev $target-desc)\n    (= target-desc \"$target-desc--$http-host\")))\n\n\n  // (main) isn't being found through /refer-to inheritance, eg. Tests -> BaseTests\n  // (if (undef? $main) (return (no-main)))\n\n  (var-clear main)\n  (desc-read self $target-desc {reload 1})\n  (if (undef? $self) (desc-read self $target-desc-prev  {reload 1}))\n  (if (undef? $self) (return ((no-joy \"http status 404 $_err\" $_cs 6))))\n\n  (if (undef? $main) (def-hash-fn $self / main))\n\n  // NB: dplx has now assumed the identity of $target-desc.\n  //     Subsequent references to $self are to $target-desc not dplx.\n  //  The following code effectively runs in the context of $target-desc.\n  //  but still retains functions defined in dplx.\n\n  (catch\n     (if (defined? $handler-pre) (handler-pre))\n     (no-joy \"http status 404 $_err\" $_cs 3))\n\n  (catch\n    (if (matching-handler--no-response) (main $req-info))\n    (no-joy \"http status 404 $_err\" $_cs 2))\n)",
   "no-joy" : "(fn (err cs n  tmp)\n  // Set response status from exception message.\n  (if (defined? $err) (do\n    (= rc (split ' ' $err))\n    (if (&& (eq http (shift $rc)) (eq status (shift $rc)))\n       (printf 'Status: %d %s\\r\\n' (shift $rc) (= err (join ' ' $rc))))))\n\n  (return (reply-json {\n    1-msg       (sprintf 'dplx: no joy here! (%s) %s' $n $path-info)\n\n    @(if (defined? $err) {\n      2-exception (if (string? $err) $err (desc-to-string $err)) })\n\n    @(if (defined? $cs) {\n      3-callstack $cs })\n  }))\n\n\n  (ct)(bl)\n\n  (printf '%s\\n' (sprintf 'dplx: no joy here! (%s) %s' $n $path-info))\n  // (var-dump)\n\n  (if (defined? $err)\n    (printf \"dplx: Exception: '%s'\\n\" (if (string? $err)\n                                        $err\n                                        (desc-to-string $err))))\n\n  (if (defined? $cs)\n    (printf 'dplx: Stack: %s\\n' (desc-to-string $cs)))\n)",
   "no-main" : "(fn ()\n  (printf 'Status: %d %s\\r\\n' 404 'Not Found')\n  (ct)(bl)\n  (print 'dplx: hello world, no (main) found!\\n')\n)",
   "no-target" : "(fn () (redirect-to \"http://${host}/api/dplx/top-page\"))",
   "on-load" : "(fn ()\n  (desc-read system-version system-version)\n  (if (!(string? $system-version)) (= system-version ''))\n\n  (def-hash-fn $self {\n    / [\n      main\n      no-target\n      no-main\n      no-joy\n      handler-pre\n    ]\n\n    /reply [\n      bl\n      ct\n      reply-html.gz\n      reply-json.gz\n      reply-html\n      reply-json\n      reply-text\n    ]\n\n    /util [\n      get-version-string\n      get-versioned-title\n      get-versioned-title-html\n      redirect-to\n      get-http-basic-credentials\n      reject-http-basic-credentials\n      copy-qh-params-to-vars\n      xml-parse\n      xml-node-to-json\n      self-url\n    ]\n\n    /util/cookies [\n      http-cookies\n      http-get-cookie\n      http-set-cookie\n      http-clear-cookie\n    ]\n\n    /api [\n      update-api-rules\n      update-api-rules-1\n      update-api-rules-2\n      hash-set-unless-set\n      find-handler\n      match-wildcards\n      matching-handler--no-response\n    ]\n  })\n\n  (= hash-set-unless-set $hash-set-unless-set {ismacro 1})\n  (= schema-path (desc-eval $self /api schema-path))\n\n  (= host (hash-get (http-headers) / Host))\n\n  (def-fn  emith (str) (emitf '%s\\r\\n' $str))\n)",
   "rcs-id" : "$Id: dplx,v 1.4 2013/09/16 05:06:39 www-data Exp www-data $",
   "reply" : {
      "bl" : "(fn ()\n  (= response-header-complete 1)\n  (emith ''))",
      "ct" : "(fn (type)\n  (emitf 'Content-Type: %s; charset=UTF-8\\r\\n'\n    (if (defined? $type) $type text/plain)))",
      "reply-html" : "(fn (html html2)\n  (ct text/html)(bl)\n  (emit (utf8-encode $html))\n  (if (defined? $html2) (do\n    (println)\n    (emit (utf8-encode $html2))\n  )))",
      "reply-html.gz" : "(fn (gz)\n  (ct text/html)\n  (emith 'Content-Encoding: gzip') \n  (bl)\n  (emit $gz))",
      "reply-json" : "//  (ct application/json)(bl)\n//  /* TODO: should be (print) maybe? */\n//  (print (desc-to-string $resp))\n\n(fn (resp gzip?)\n  (= resp (desc-to-string $resp {utf8 1}))\n  (ct application/json)\n\n  (if (defined&&1? $gzip?)\n    (do\n      (emith 'Content-Encoding: gzip') \n      (bl)\n      (emit (gzip $resp)))\n    (do\n      (bl)\n      (print $resp))))",
      "reply-json.gz" : "(fn (gz)\n  (if (undef? $gz) (return (reply-json $gz)))\n\n  (ct application/json)\n  (emith 'Content-Encoding: gzip') \n  (bl)\n  (emit $gz))",
      "reply-text" : "(fn (&texts)\n  (ct)(bl)\n  (map-list emit $texts)\n  ())"
   },
   "request-from-client" : {
      "schema" : {
         "HTTP" : {
            "GET" : {
               ".on-match." : "(no-target 1)\n()",
               "version" : {
                  ".on-match." : "(= rcs (split ' ' (hash-get $self / rcs-id)))\n\n(ct application/json)(bl)\n(print (desc-to-string (hash\n    DPL          (version)\n    $target-desc (hash\n        date       (join - (split '\\\\/' (ith $rcs 3)))\n        version    (ith $rcs 2))\n)))"
               }
            }
         }
      }
   },
   "respose-to-client" : {
      "schema" : {}
   },
   "util" : {
      "cookies" : {
         "http-clear-cookie" : "(fn (name)\n  (hash-clear $cookies / $name)\n  (http-set-cookie $name '' {\n    path     /api\n    Expires 'Tue, 01-Jan-2013 00:00:00'\n  }))",
         "http-cookies" : "(fn ( -- chash)\n  // (report 'hdr: %s' (desc-to-string (http-headers)))\n  (= chash {})\n\n  (map-list (fn (nv)\n      // (report 'cookie: %s' $nv)\n      (= n-v (split = $nv))\n      (= n (shift $n-v))\n      (= v (join = $n-v))\n      (hash-set $chash / $n $v))\n    (split '; ' (hash-get (http-headers) / Cookie)))\n\n  $chash\n)",
         "http-get-cookie" : "(fn (name)\n  (hash-get $cookies / $name))",
         "http-set-cookie" : "(fn (name val params -- params-val header-line)   \n  (if (defined? params)\n    (= params-val\n      (join '; '\n        (foreach key (hash-keys $params)\n          (sprintf %s=%s $key (hash-get $params / $key))))))\n\n\n  (= header-line (if (defined? $params-val)\n    \"Set-Cookie: $name=${val}; $params-val\"\n    \"Set-Cookie: $name=$val\"))\n\n  (hash-set $cookies / $name $val)\n\n  (emith $header-line)\n  $val)"
      },
      "copy-qh-params-to-vars" : "// Copy the values of any query string parameter whose name is in $names\n// to the variables of the same name.\n \n(fn (names -- val)\n  (foreach name $names\n    (if (defined? (= val (hash-get $query-hash / $name)))\n      (= $name $val))))",
      "get-http-basic-credentials" : "(def-fn get-credentials-from-query-hash ()\n  (copy-qh-params-to-vars [user passwd]))\n\n#### TODO confirm these are correct with some auth service...\n(fn (realm reject -- auth user passwd error)\n  // peek at query string first...\n  (get-credentials-from-query-hash)\n  (if (&& (defined? $user) (defined? $passwd))\n    (return $[user passwd]))\n\n\n  // look in header now.\n  (= auth (split ' ' (hash-get (http-headers) / Authorization)))\n\n  (if (list-len $auth) (if\n    (eq Basic (first $auth)) (= auth (next $auth))\n    // ...\n    (throw (sprintf 'Unknown HTTP Auth method: %s' (first $auth)))\n  ))\n\n  (if (string? $auth) (do\n    (= auth   (split : (base64-decode $auth)))\n    (= user   (first $auth))\n    (= passwd (next  $auth))\n  ))\n\n  (if (|| $reject (undef? $user) (undef? $passwd) (eq '' $user) (eq '' $passwd))\n    (reject-http-basic-credentials $realm))\n\n  $[user passwd])",
      "get-version-string" : "(fn (desc -- vers)\n  (if (undef? $desc) (= desc $self))\n  (= vers (split ' ' (hash-get $desc / rcs-id)))\n  (sprintf 'v%s  %sT%sZ'\n    (ith $vers 2)\n    (join - (split / (ith $vers 3)))\n    (ith $vers 4)))",
      "get-versioned-title" : "(fn (title desc)\n  (sprintf '%s  %s' $title (get-version-string $desc)))",
      "get-versioned-title-html" : "(fn (title desc)\n  (sprintf '%s  %s%s%s' $title '<font size=\"-1\">' (get-version-string $desc) </font>))",
      "redirect-to" : "(fn (url)\n  // (report ' >> (%s %s)' $. $url)\n  (emith \"Status: 302 Found\")\n  (emith \"Location: $url\")\n  (bl)\n)",
      "reject-http-basic-credentials" : "(fn (realm -- error)\n  (= error '401 Unauthorized')\n\n  (emith \"Status: $error\")\n  (emith \"WWW-Authenticate: Basic realm=\\\"$realm\\\"\")\n  (ct)(bl)\n  (println $error)\n\n  (throw $error))",
      "self-url" : "// $action is 'e' for edit or 'x' for execute.\n// $path is the path after /api/dplx\n// $workspace is the workspace for this request\n\n(fn (action path workspace)\n  (=? path '')\n  (=? workspace $self-url--default-workspace)\n  (=? workspace /)\n\n  (= workspace\n    (if (defined? $workspace)\n      (sprintf '?_workspaceName=%s'\n        (urlencode (utf8-encode $workspace))) ''))\n\n  (sprintf /api/dpl%s/%s%s%s\n    $action\n    $self/name\n    $path\n    $workspace\n  ))",
      "xml-node-to-json" : "(fn (node -- out)\n  //(if (! (hash? $node))\n  //   (throw \"node should be an instance and is '$node'\"))\n\n  (= out {})\n\n  (foreach child ($node childNodes)\n      // (report \"chnode type: %s\" ($child nodeType))\n      (hash-set $out / ($child nodeName)\n          (if\n             ($child hasChildNodes)     (xml-node-to-json $child)\n             (eq '3' ($child nodeType)) ($child textContent))))\n\n  $out)",
      "xml-parse" : "(fn (xml) ((pm-new XML::LibXML) parse_string $xml))"
   }
}
