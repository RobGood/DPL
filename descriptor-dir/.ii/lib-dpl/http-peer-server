{
   "README" : "A standalone HTTP server for dplx\n\nto start:\n  dpl -eval '(desc-read _ http-peer-server) (emit (desc-to-string (server-start)))'\n\nto stop:\n  dpl -eval '(desc-read _ http-peer-server) (emit (desc-to-string (server-stop)))'\n\nto get status:\n  dpl -eval '(desc-read _ http-peer-server) (emit (desc-to-string (server-status)))'",
   "_dateCreated" : "Thu Mar 28 02:34:50 2013",
   "_useCount" : 110,
   "api" : {
      "admin" : {
         "README" : "These are functions for working with the server workers.",
         "server-start" : "(fn (port)\n  (=? port $default-port)\n  (worker-start Peer-server dev 1 (run-peer-server $port))\n)",
         "server-status" : "(fn ()\n (worker-status Peer-server dev 1))",
         "server-stop" : "(fn ()\n (worker-stop Peer-server dev 1))"
      },
      "dplx" : {
         "README" : "This sets up a call to the appropriate descriptor.",
         "handle-dplx" : "(def-fn def-capture-fns ()\n  (def-fn print   (&args) (emit  @(map-list utf8-encode $args)     ))\n  (def-fn printf  (&args) (emitf @(map-list utf8-encode $args)     ))\n  (def-fn println (&args) (emit  @(map-list utf8-encode $args) '\\n'))\n\n  (def-fn _get-stashed-writes ()\n    (if (defined? $response-header-complete)\n      $stashed-body-writes\n      $stashed-header-writes))\n\n  (def-fn emit (&args)  (push (_get-stashed-writes) @$args))\n  (def-fn emitf (&args) (push (_get-stashed-writes) (sprintf @$args)))\n)\n\n-----\n(fn (req-info -- status headers body main\n              -- emit emitf print printf println\n              -- cookies args )\n\n  // capture data in calls to emit* and print*\n  // stash it and dump it out later after status line\n\n#---\n# from dplx,\n# this part should run in the interpreter returned by (DPL-login)\n  (= tmp (DPL-login $workspace-name))\n  (assert 'got something  from (DPL-login)' (defined? $tmp))\n\n  // See PrimaLisp.pm DPL_login() return.\n  (= ii                  (shift $tmp))\n  (= DPL-auth            (shift $tmp))\n  (= DPL-userid          (shift $tmp))\n  (= workspace-name      (shift $tmp))\n  (= workspace-name-list (shift $tmp))\n\n  (assert 'used up everything from (DPL-login)' (== 0 (list-len $tmp)))\n\n  (= args $[req-info def-capture-fns workspace-name workspace-name-list])\n\n  (catch (ii-eval $ii $[args]\n    (= $args)\n\n    (= userid (login))\n\n    ((fn (acl) (if (defined? $acl) ($acl check)))\n      (catch (new-inst dpl-access $req-info)))\n\n    (desc-read self dplx {reload 1})\n    (def-capture-fns)\n\n    (= stashed-header-writes [])\n    (= stashed-body-writes   [])\n\n    (main $req-info)\n\n    (= status-lines\n      (grep (fn (_ -- s)\n              (= s (split ': ' $_))\n              (eq (ith $s 0) Status))\n        $stashed-header-writes))\n\n    (if (defined? (= parts (split '\\s+' (shift $status-lines)))) (do\n      (shift $parts)\n      (= code (shift $parts))\n      (= msg (join ' ' $parts))\n      (= status [$code $msg])\n    ))\n\n    // remove blank line between  header and body before returning body.\n    (shift $stashed-body-writes)\n\n    (=? status  [200 Ok])\n    (= headers (concat $stashed-header-writes))\n    (= body    (utf8-encode (concat $stashed-body-writes)))\n\n    $[status headers body]\n  )\n\n  {\n    status [500 Oops]\n    headers 'Content-Type: application/json; charset=UTF-8\\r\\n'\n    body   (desc-to-string $[_err _cs])\n  }))"
      },
      "workers" : {
         "README" : "These workers give HTTP clients persistant DPL runtime environments",
         "run-client-peer" : "// This runs the HTTP client peer.\n// Normally the connection is used for multiple\n// request/response rounds.\n\n(def-fn http-status-line (code msg)\n   (sprintf 'HTTP/1.1 %d %s' $code $msg))\n\n(def-fn fixup-path ( -- path-list)\n  (= path-list (hash-get $req-info / path-list))\n  (=? path-list (split / (hash-get $req-info / path-info)))\n  (shift $path-list)\n\n  (if (eq api (ith $path-list 0))\n    (shift $path-list))\n\n  (if (eq dplx (ith $path-list 0))\n    (shift $path-list))\n\n  (unshift $path-list '')\n  (hash-set $req-info / path-info (join / $path-list))\n  (shift $path-list)\n  (hash-set $req-info / path-list $path-list)\n)\n\n\n(def-fn handle-one-request ( -- req-info resp-info body body-length)\n  (report ' ** Reading next request...')\n  (= req-info (socket-in-http $conn))\n\n  (fixup-path)\n\n  (report ' ** Handling request...')\n  (= (handle-dplx $req-info))\n\n// (report-vars status headers body)\n\n  (= body-length (len $body))\n  (=? body-length 0)\n  (report ' ** Sending next response... %d %s' $body-length $body)\n// (report %s $headers)\n\n  (socket-out $conn\n    (http-status-line @$status)    '\\r\\n'\n    'Connection: keep-alive'       '\\r\\n'\n    \"Content-Length: $body-length\" '\\r\\n'\n    $headers\n    '\\r\\n'\n    $body))\n\n------\n(fn (conn)\n (while (! (socket-eof? $conn))\n   (report ' ** calling handler for next request...')\n   (handle-one-request))\n\n (report ' ** Done.')\n (socket-close2 $conn))",
         "run-peer-server" : "// This runs the HTTP server.\n// When an HTTP client connects,\n// a new worker becomes the client's peer for\n// the duration of the socket connection.\n\n(fn (port -- id listener conn)\n  (= listener (catch (socket-listener $port)\n                (report 'Exception: %s' $_err)\n                (exit 1)))\n\n  (= id 0)\n  (while 1\n    (report ' ** Waiting for a connection...')\n    (= conn (socket-accept $listener))\n    (++id)\n    (report ' ** id %d Got a connection...' $id)\n    (worker-start Peer dev $id (run-client-peer $conn))\n    (socket-close2 $conn)\n\n    (report Zzzz...) (sleep 0.05)\n  ))"
      }
   },
   "api-entry-points" : "{\n  GET/  1\n}",
   "on-load" : "(fn ()\n  (bi-import Core_sockets!)\n\n  (def-hash-fn $self {\n    /api/workers [\n      run-peer-server\n      run-client-peer\n    ]\n\n    /api/admin [\n      server-start\n      server-stop\n      server-status\n    ]\n\n    /api/dplx [\n      handle-dplx\n    ]\n  })\n\n  (= default-port 9123)\n)",
   "rcs-id" : "$Id: http-peer-server,v 1.153 2013/04/10 17:55:44 apache Exp apache $"
}
