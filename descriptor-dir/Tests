{
   "_dateCreated" : "Fri Oct 22 00:38:28 2010",
   "_useCount" : 951,
   "finish" : "(desc-write $self Tests.results)",
   "get-tests" : "(map-list (fn (_) (report 'Test: /%s' $_) \"/$_\")\n  (sort-alpha\n    (grep (fn (_) (eq tests- (substr $_ 0 6)))\n      (desc-keys $self /))))",
   "rcs-id" : "$Id: Tests,v 1.374 2013/04/18 19:05:19 apache Exp apache $",
   "refer-to" : "BaseTests",
   "request-from-client" : {
      "schema" : {
         "HTTP" : {
            "GET" : {
               ".on-match." : "// This was needed after mods to descriptor dplx to\n// handle api specification via 'request-from-client/schema'\n// Returning non-zero here forces running of (main) to run the tests.\n1"
            }
         }
      }
   },
   "tests-00" : {
      "a000" : "(fn () '')",
      "a000.expect" : "{value ''}",
      "a001" : "(fn ()  '`~!@#$%^&*()_+-={}|[];:\",<.>/?')",
      "a001.expect" : "{value '`~!@#$%^&*()_+-={}|[];:\",<.>/?'}",
      "a002" : "(fn () (join ' ' (list 1 2 3)))",
      "a002.expect" : "{value '1 2 3'}",
      "a003" : "(fn () ())",
      "a003.expect" : "{value ()}",
      "a100" : "(fn () (is-defined ()))",
      "a100.expect" : "{value 0}",
      "a101" : "(fn () (is-undef ()))",
      "a101.expect" : "{value 1}",
      "t00" : "(fn () (+ 1 1 1))",
      "t00.expect" : "{value 3}",
      "t011" : "(fn () (list-len (list 1 2 3)))",
      "t011.expect" : "{value 3}",
      "t012" : "(fn () (list-len (split '\\\\.' '1.2.3')))",
      "t012.expect" : "{value 3}",
      "t012a" : "(fn () (list-len (split ' ' '1 2 3')))",
      "t012a.expect" : "{value 3}",
      "t02" : "(fn () (throw something))",
      "t02.expect" : "{exception something}",
      "t03" : "(fn ()\n  (var-set tmp (list))\n  (var-set n 10)\n\n  (while (> $n 0) (push $tmp $n) (var-set n (- $n 1)))\n  (push $tmp --)\n  (push $tmp (- (list-len $tmp) 1))\n  (join ' ' (reverse $tmp))\n)",
      "t03.expect" : "{value '10 -- 1 2 3 4 5 6 7 8 9 10'}",
      "t04" : "(fn () (<< 1 10))",
      "t04.expect" : "{value 1024}"
   },
   "tests-01" : {
      "aop-00.fn-1" : "(fn (arg) (push $test-results-list \"arg: $arg\"))",
      "aop-00.fn-2" : "(fn (arg) (push $test-results-list \"arg: $arg\"))",
      "aop-00.fn-inj" : "(fn (arg) (push $test-results-list \"----\"))",
      "aop-000" : "(fn ()\n  (var-set test-results-list (list))\n\n  (var-set fn-1 (desc-eval $self /tests-01 aop-00.fn-1))\n  (fn-1 'hello world')\n\n  (var-set fn-2 (desc-eval $self /tests-01 aop-00.fn-2))\n\n  (map-list (fn (i) (push $test-results-list \" 1-> $i\")) $fn-1)\n  (map-list (fn (i) (push $test-results-list \" 2-> $i\")) $fn-2)\n  (fn-2 'hello world')\n)",
      "aop-000.expect" : "{value 'arg: hello world'}",
      "macro-demo" : "(fn ()\n  (var-set test-results-list (list))\n\n  (var-set test-fn (fn (word x y)\n    (push $test-results-list         \"$word  \")\n    (push $test-results-list (sprintf 'x: <|%s|>  ' $x))\n    (push $test-results-list (sprintf 'y: <|%s|> -- ' $y))\n   ))\n\n  (test-fn function (* 10 10) (time))\n  (var-set test-fn/ismacro 1)\n  (test-fn macro    (* 10 10) (time))\n\n  (report (join '' $test-results-list)))",
      "macro-demo.expect" : "{value ()}",
      "macro-use" : "(fn ()\n  (var-set  test-macro\n    (fn (x)\n      (sprintf '%s = %s' $x (eval $x)))\n    {ismacro 1})\n\n  (test-macro (* 10 10))\n)",
      "macro-use.expect" : "{value \"(* 10 10) = 100\"}",
      "var-attrs" : "(fn ()\n  (var-set test 42 {temp 70})\n  $test/temp\n)",
      "var-attrs.expect" : "{value 70}"
   },
   "tests-02" : {
      "arith-00" : "(fn () (+ 1 (* 4 (/ 10 3))))",
      "arith-00.expect" : "{value (/ 43 3)}",
      "concat-00" : "(fn ()\n  (var-set vertical   news)\n  (var-set query-term oil)\n  (concat '/ysearch/' (get-var vertical) '/v1/' (get-var query-term))\n)",
      "concat-00.expect" : "{value '/ysearch/news/v1/oil'}",
      "concat-01" : "(fn ()\n  (var-set vertical   news)\n  (var-set query-term oil)\n  (concat \"/ysearch/$vertical/v1/$query-term\")\n)",
      "concat-01.expect" : "{value '/ysearch/news/v1/oil'}",
      "escape-00" : "(fn ()  '\\\\\\'\\\\')",
      "escape-00.expect" : "{value '\\\\\\'\\\\'}",
      "fn-00" : "(fn ()\n  (var-set dist (fn (x y z) (+ (* $x $x) (* $y $y) (* $z $z))))\n  (dist 1 2 3)\n)",
      "fn-00.expect" : "{value '14'}",
      "if-00" : "(fn ()\n  (var-set out (list))\n  (push $out (if 1 A-1 0 A-2 0 A-3 B))\n  (push $out (if 1 A-1 1 A-2 1 A-3 B))\n  (push $out (if 0 A-1 1 A-2 1 A-3 B))\n  (push $out (if 0 A-1 0 A-2 1 A-3 B))\n  (push $out (if 0 A-1 0 A-2 0 A-3 B))\n  (join ' ' $out)\n)",
      "if-00.expect" : "{value 'A-1 A-1 A-2 A-3 B'}",
      "no-fn-00" : "(fn () (no-fn foo))",
      "no-fn-00.expect" : "{exception 'An undefined function \\'no-fn\\' was called.'}",
      "no-fn-01" : "// This page intentionally left blank.",
      "no-fn-01.expect" : "//{value ())\n{exception \"An undefined function '' was called.\"}",
      "urlencode-00" : "(fn ()\n  (urlencode '`~!@#$%^&*()_-+={}[]|\\\\:\\'\"<>,.?/')\n)",
      "urlencode-00.expect" : "{value '%60~%21%40%23%24%25%5E%26%2A%28%29_-%2B%3D%7B%7D%5B%5D%7C%5C%3A%27%22%3C%3E%2C.%3F%2F'}"
   },
   "tests-03" : {
      "catch-00" : "(fn ()\n  (catch (throw 42) $_err)\n)",
      "catch-00.expect" : "{value 42}",
      "catch-000" : "(fn ()\n  (catch (+ 1 (+ 1 (throw 42))) $_err)\n)",
      "catch-000.expect" : "{value 42}",
      "catch-01" : "(fn () (catch (return 42) xx))",
      "catch-01.expect" : "{value 42}",
      "drop-builtins" : "(fn ()\n  // Whatever is dropped here stays dropped for the rest of the tests!\n  (drop-builtins exit)\n  (exit)\n  (report \" !! Fell through exception here!\")\n)",
      "drop-builtins.expect" : "{exception \"Dropped builtin function 'exit' was called.\"}",
      "namespace-00" : "(fn ()\n  (report (concat \"pid: \" $pid))\n \n  (namespace \"Test.$pid\" {pid $pid}\n    (var-set hw (fn (name) \"Hello $name\"))\n    (report (hw zzzz))\n\n    // (dump-vars)\n    (report (sprintf \"pid: %s, ns: %s\" $pid (namespace)))\n    (namespace))\n)",
      "namespace-00.expect" : "{value \"Test.$pid\"}",
      "namespace-01" : "(fn ()\n  (namespace \"Test.$pid\" {pid $pid}\n    (catch (throw 42) $_err)))",
      "namespace-01.expect" : "{value 42}",
      "namespace-02" : "(fn ()\n  (catch\n    (namespace \"Test.$pid\" $[pid]\n      (throw 42))\n     (throw $_err)\n))",
      "namespace-02.expect" : "{exception 42}",
      "namespace-access-00" : "(fn ()\n  (var-set sq (* 9 9))\n  (namespace () ()\n    // eval'd in current varMap.\n    (var-set sq (* 8 8)))\n\n  (join ' ' (list $sq (namespace () () $sq)))\n)",
      "namespace-access-00.expect" : "{value '64 64'}",
      "namespace-access-01" : "(fn ()\n  (var-set sq (* 9 9))\n  (namespace ns1 ()\n    // eval'd in ns1 varMap.\n    (var-set sq (* 8 8)))\n\n  (join ' ' (list $sq (namespace ns1 () $sq)))\n)",
      "namespace-access-01.expect" : "{value '81 64'}",
      "namespace-access-02" : "(fn ()\n  (var-set sq (* 9 9))\n  (namespace ns1 $[sq]\n    // eval'd in ns1 varMap.\n    (var-set sq (* $sq $sq)))\n\n  (join ' ' (list $sq (namespace ns1 () $sq)))\n)",
      "namespace-access-02.expect" : "{value '81 6561'}",
      "namespace-lexical" : "(fn ()\n  (var-set test-fn (fn () $sq))\n\n  (var-set out (list))\n  (var-set sq (* 9 9))\n\n  (push $out $sq)\n  (push $out (test-fn))\n\n  (namespace () {sq 42}\n     // (dump-vars)\n     (push $out $sq)\n     (push $out (test-fn))\n  )\n\n  (push $out $sq)\n  (push $out (test-fn))\n\n  (join ' ' $out))",
      "namespace-lexical.expect" : "{value '81 81 42 81 81 81'}",
      "varargs-00" : "(fn ()\n  (var-set fn0 (fn (x y z &rest)\n    (sprintf '%s %s %s %s' $x $y $z (join '-' $rest))))\n  // (dump-vars)\n  (fn0 1 2 3 4 5 6 7 8 9 10)\n)",
      "varargs-00.expect" : "{value '1 2 3 4-5-6-7-8-9-10'}"
   },
   "tests-04" : {
      "comma-functions-00" : "(fn () \n  (= foo (fn () ,$x) {ismacro 1})\n  $foo\n)",
      "comma-functions-00.expect" : "{value '(fn () ,$x)'}",
      "help-00" : "(fn ()\n  /* This one is tricky to fix, so defer...\n   (assert\n    'An exact match should return single item list'\n    (== 1 (list-len (help *))))\n  */\n  ()\n)",
      "help-00.expect" : "{value ()}",
      "incr-decr-00" : "(fn ( -- xxx)\n  (= out (list))\n  (= xxx 42)       (push $out $xxx)\n\n  (push $out (_++ xxx))  (push $out $xxx)\n  (push $out (++_ xxx))  (push $out $xxx)\n  (push $out (--_ xxx))  (push $out $xxx)\n  (push $out (_-- xxx))  (push $out $xxx)\n\n  (join ' ' $out)\n)",
      "incr-decr-00.expect" : "{value '42 42 43 44 44 43 43 43 42'}",
      "macro-comma-00" : "(fn () \n  // It seems that tests running in their own namespace\n  // loose out on initialization definitions.\n  // So we'll make an inner interpreter to run our test in...\n\n  // But now the first problems is solved (2100-06-16)\n  // this test fails in the inner interpreter.\n\n  (= z 420)\n\n  // (ii-eval (ii-new ii) \n    (= z 42)\n    (def-macro foo (x)  (sprintf 'Got %s %s' $x (eval $x)))\n    (def-fn doit ()\n       (sprintf '%s. %s.' (foo $z) (foo ,$z)))\n\n    (var-dump)\n  // (doit)\n  // )\n\n   (doit)\n)",
      "macro-comma-00.expect" : "{value 'Got $z 42. Got 42 42.'}",
      "stats-00" : "// Report stats to test log.\n(fn ()\n  (var-set s (statistics))\n  (map-list (fn (k)\n    (report (sprintf '%s : %s' $k (hash-get $s / $k))))\n    (sort-alpha (hash-keys $s /)))\n  ()\n)",
      "stats-00.expect" : "{value ()}",
      "whitelist-00" : "(fn ()\n  (is-defined (pm-new XML::LibXML))\n)",
      "whitelist-00.expect" : "{value 1}"
   },
   "tests-05" : {
      "early-out-AND-00" : "(fn ()\n  (&& 1 2 3 0 (/ 1 0)))",
      "early-out-AND-00.expect" : "{value 0}",
      "early-out-AND-01" : "(fn ()\n  (&& 0 0 0 0 (/ 1 0)))",
      "early-out-AND-01.expect" : "{value 0}",
      "early-out-AND-02" : "(fn ()\n  (&& 1 2 3 4 (/ 1 0)))",
      "early-out-AND-02.expect" : "{exception 'Illegal division by zero at (eval 29) line 960.\\n'}",
      "early-out-AND-03" : "(fn ()\n  (&& 1 2 3 4))",
      "early-out-AND-03.expect" : "{value 4}",
      "early-out-OR-00" : "(fn ()\n  (|| 1 2 3 4 (/ 1 0)))",
      "early-out-OR-00.expect" : "{value 1}",
      "early-out-OR-01" : "(fn ()\n  (|| 0 0 0 1 (/ 1 0)))",
      "early-out-OR-01.expect" : "{value 1}",
      "early-out-OR-02" : "(fn ()\n  (|| 0 0 0 0 (/ 1 0)))",
      "early-out-OR-02.expect" : "{exception 'Illegal division by zero at (eval 29) line 960.\\n'}",
      "early-out-OR-03" : "(fn ()\n  (|| 0 0 0 0))",
      "early-out-OR-03.expect" : "{value 0}",
      "early-out-OR.expect" : "{value 1}"
   },
   "tests-06" : {
      "callstack-popping-00" : "(fn ()\n  (def-fn xx () (return))\n\n  (= depth-before (list-len (callstack)))\n  (foreach i (.. 1 10) (xx))\n  (= depth-after (list-len (callstack)))\n\n  (- $depth-after $depth-before)\n)",
      "callstack-popping-00.expect" : "{value 0}",
      "callstack-popping-01" : "(fn ()\n  (def-fn xx () )\n\n  (= depth-before (list-len (callstack)))\n  (foreach i (.. 1 10) (xx))\n  (= depth-after (list-len (callstack)))\n\n  (- $depth-after $depth-before)\n)",
      "callstack-popping-01.expect" : "{value 0}",
      "callstack-popping-02" : "(fn ()\n  (def-fn xx () (throw Boo!))\n\n  (= depth-before (list-len (callstack)))\n  (catch (foreach i (.. 1 10) (xx)))\n  (= depth-after (list-len (callstack)))\n\n  (- $depth-after $depth-before)\n)",
      "callstack-popping-02.expect" : "{value 0}",
      "callstack-popping-03" : "(fn ()\n  (def-fn xx () (throw Boo!))\n\n  (= i 1)\n  (= depth-before (list-len (callstack)))\n  (catch (while (<= $i 10) (++_ i) (xx)))\n  (= depth-after (list-len (callstack)))\n\n  (- $depth-after $depth-before)\n)",
      "callstack-popping-03.expect" : "{value 0}",
      "callstack-popping-04" : "(fn ()\n  (def-fn xx () (yy))\n  (def-fn yy () (return))\n\n  (= i 1)\n  (= depth-before (list-len (callstack)))\n  (catch (while (<= $i 10) (++_ i) (xx)))\n  (= depth-after (list-len (callstack)))\n\n  (- $depth-after $depth-before)\n)",
      "callstack-popping-04.expect" : "{value 0}",
      "deep-copy-null-00" : "(fn () (undef? (desc-from-string (desc-to-string ()))))",
      "deep-copy-null-00.expect" : "{value 1}",
      "encoding-len-00" : "(fn () (len 'хорошо'))",
      "encoding-len-00.expect" : "{value 6}",
      "encoding-substr-00" : "(fn ()  (substr 'хорошо' 3 3))",
      "encoding-substr-00.expect" : "{value 'ошо'}",
      "hash-clear-debug" : "(fn () (hash-clear {a 12 b 24 c 48} / b))",
      "hash-clear-debug.expect" : "{value 24}",
      "hash-subtract-01" : "(fn ()\n  (desc-to-string\n    (hash-subtract\n      {X {a 10} Y 78 Z 1}\n      {X {a  8} Y 45 Z 1})))",
      "hash-subtract-01.expect" : "{value (desc-to-string {\n  X {a [(int 2) (int 10) (int 8)]}\n  Y [(int 33) (int 78) (int 45)]\n  Z  1\n})}",
      "var-clobber-00" : "(fn ()\n  (= bass 42)\n\n  (def-fn zzz (&attrs -- bass)\n    (= bass (join - $attrs)))\n\n  (zzz 1 2 3 4 5 6 7 8 9)\n\n  $bass\n)",
      "var-clobber-00.expect" : "{value 42}"
   },
   "tests-07" : {
      "crypto-01" : "(fn ()\n  (= s 32)\n  (= v1 (rand-data $s))\n  (= v2 (rand-data $s))\n  (= v3 (^ $v1 $v2))\n\n  (assert '(rand-data) returns requested length of data'\n    (&&\n      (== $s (len $v1))\n      (== $s (len $v2))\n      (== $s (len $v3))))\n\n\n\n  (= v3.1 (^ $v3 $v1))\n  (= v3.2 (^ $v3 $v2))\n\n  (assert 'xor works'\n    (&&\n      (== $s (len $v3.1))\n      (== $s (len $v3.2))\n      (eq $v3.1 $v2)\n      (eq $v3.2 $v1)))\n\n  ok)",
      "crypto-01.expect" : "{value ok}",
      "crypto-02" : "(fn ()\n  (= key        (rand-data 32))\n\n  (= clear-data (sprintf 'abcdefghijklmnopqrstuvwxyz %s' (rand-guid)))\n  (= crypt-data (encrypt $key $clear-data))\n\n  (assert 'clear and crypt data are different at least' (ne $clear-data $crypt-data))\n\n  (= clear-data-2 (decrypt $key $crypt-data))\n\n  (assert 'original and decrypted data are the same' (eq $clear-data $clear-data-2))\n\n  (report 'key: %s' (hex-encode $key))\n  (report 'crypt: %s' (hex-encode $crypt-data))\n  (report-vars clear-data clear-data-2)\n\n  ok)",
      "crypto-02.expect" : "{value ok}",
      "masking-01" : "(fn ()\n  (= data (rand-data 64))\n  (report 'data: %s' (base64-encode $data))\n\n  (= masked (data-mask $data))\n  (report-vars masked)\n\n  (= data-2 (data-unmask $masked))\n  (report 'data-2: %s' (base64-encode $data-2))\n\n  (assert 'got the same thing we started with' (eq $data $data-2))\n\n  ok)",
      "masking-01.expect" : "{value ok}",
      "meta-vars-01" : "(fn ( -- xx yy)\n  (hash-get $[xx yy] / xx))",
      "meta-vars-01.expect" : "{value ()}",
      "meta-vars-02" : "(fn ( -- xx yy)\n  (var-clear xx yy)\n  (hash-get $[xx yy] / xx))",
      "meta-vars-02.expect" : "{value ()}",
      "undef-join-arg-01" : "(fn () (join / ()))",
      "undef-join-arg-01.expect" : "{value ()}"
   }
}
